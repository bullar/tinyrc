
TinyRC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000376  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00800060  00000376  0000040a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000060  00800094  00800094  0000043e  2**0
                  ALLOC
  3 .debug_aranges 00000060  00000000  00000000  0000043e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000002a1  00000000  00000000  0000049e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000007bb  00000000  00000000  0000073f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002da  00000000  00000000  00000efa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000004c1  00000000  00000000  000011d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000160  00000000  00000000  00001698  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002f9  00000000  00000000  000017f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000000be  00000000  00000000  00001af1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	28 c0       	rjmp	.+80     	; 0x54 <__bad_interrupt>
   4:	7b c0       	rjmp	.+246    	; 0xfc <__vector_2>
   6:	fd c0       	rjmp	.+506    	; 0x202 <__vector_3>
   8:	f2 c0       	rjmp	.+484    	; 0x1ee <__vector_4>
   a:	b3 c0       	rjmp	.+358    	; 0x172 <__vector_5>
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	21 c0       	rjmp	.+66     	; 0x54 <__bad_interrupt>
  12:	71 c1       	rjmp	.+738    	; 0x2f6 <__vector_9>
  14:	cc c0       	rjmp	.+408    	; 0x1ae <__vector_10>
  16:	d5 c0       	rjmp	.+426    	; 0x1c2 <__vector_11>
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>

0000001e <__ctors_end>:
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf e5       	ldi	r28, 0x5F	; 95
  24:	d1 e0       	ldi	r29, 0x01	; 1
  26:	de bf       	out	0x3e, r29	; 62
  28:	cd bf       	out	0x3d, r28	; 61

0000002a <__do_copy_data>:
  2a:	10 e0       	ldi	r17, 0x00	; 0
  2c:	a0 e6       	ldi	r26, 0x60	; 96
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	e6 e7       	ldi	r30, 0x76	; 118
  32:	f3 e0       	ldi	r31, 0x03	; 3
  34:	02 c0       	rjmp	.+4      	; 0x3a <.do_copy_data_start>

00000036 <.do_copy_data_loop>:
  36:	05 90       	lpm	r0, Z+
  38:	0d 92       	st	X+, r0

0000003a <.do_copy_data_start>:
  3a:	a4 39       	cpi	r26, 0x94	; 148
  3c:	b1 07       	cpc	r27, r17
  3e:	d9 f7       	brne	.-10     	; 0x36 <.do_copy_data_loop>

00000040 <__do_clear_bss>:
  40:	10 e0       	ldi	r17, 0x00	; 0
  42:	a4 e9       	ldi	r26, 0x94	; 148
  44:	b0 e0       	ldi	r27, 0x00	; 0
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
  4a:	a4 3f       	cpi	r26, 0xF4	; 244
  4c:	b1 07       	cpc	r27, r17
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
  50:	79 d0       	rcall	.+242    	; 0x144 <main>
  52:	8f c1       	rjmp	.+798    	; 0x372 <_exit>

00000054 <__bad_interrupt>:
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <LoadSettings>:
{
  // read order of input ch from eprom
  //eeprom_read_block(ch_order_in,  (void *) CH_ORDER_IN_ADR,  MAX_OUT_CH);
  //eeprom_read_block(ch_order_out, (void *) CH_ORDER_OUT_ADR, MAX_OUT_CH);

}
  56:	08 95       	ret

00000058 <InitPort>:

void InitPort(void)
{

  // set port pins 0 and 1 as output
  DDRB = (1 << PB0)|(1 << PB1);
  58:	83 e0       	ldi	r24, 0x03	; 3
  5a:	87 bb       	out	0x17, r24	; 23


  // enable pull up resistors
  PORTB = (1 << PB4)|(1 << PB5);
  5c:	80 e3       	ldi	r24, 0x30	; 48
  5e:	88 bb       	out	0x18, r24	; 24
  INPUT_PORT_3 |= (1<<INPUT_BIT_3);
  INPUT_PORT_4 |= (1<<INPUT_BIT_4);
  INPUT_PORT_5 |= (1<<INPUT_BIT_5);
*/

}
  60:	08 95       	ret

00000062 <InitPinChange>:
  // enable pin change interrupt
  //PCICR =  (1<<PCIE2)|(1<<PCIE1);



}
  62:	08 95       	ret

00000064 <PinChangeInterrupt>:
{
  uint16_t time;
  uint16_t timeDiff;
  uint8_t pinStatus;

  time = TCNT1;
  64:	8f b5       	in	r24, 0x2f	; 47
  66:	48 2f       	mov	r20, r24
  68:	50 e0       	ldi	r21, 0x00	; 0

  // calc time difference
  timeDiff = time - lastTime;
  6a:	80 91 b8 00 	lds	r24, 0x00B8
  6e:	90 91 b9 00 	lds	r25, 0x00B9
  72:	9a 01       	movw	r18, r20
  74:	28 1b       	sub	r18, r24
  76:	39 0b       	sbc	r19, r25

  //curInCh = 4; // trottle


  pinStatus = *inPin[inSequ[curInCh]];
  78:	e0 91 96 00 	lds	r30, 0x0096
  7c:	f0 e0       	ldi	r31, 0x00	; 0
  7e:	ec 57       	subi	r30, 0x7C	; 124
  80:	ff 4f       	sbci	r31, 0xFF	; 255
  82:	a0 81       	ld	r26, Z
  84:	b0 e0       	ldi	r27, 0x00	; 0
  86:	fd 01       	movw	r30, r26
  88:	ee 0f       	add	r30, r30
  8a:	ff 1f       	adc	r31, r31
  8c:	e8 55       	subi	r30, 0x58	; 88
  8e:	ff 4f       	sbci	r31, 0xFF	; 255
  90:	01 90       	ld	r0, Z+
  92:	f0 81       	ld	r31, Z
  94:	e0 2d       	mov	r30, r0
  96:	80 81       	ld	r24, Z
  pinStatus >>= inBit[inSequ[curInCh]];
  98:	a6 52       	subi	r26, 0x26	; 38
  9a:	bf 4f       	sbci	r27, 0xFF	; 255
  9c:	ac 91       	ld	r26, X




  // check if first pulse in sequence
  if(timeDiff >= MAX_PULSE_TIME)
  9e:	9b e0       	ldi	r25, 0x0B	; 11
  a0:	28 3b       	cpi	r18, 0xB8	; 184
  a2:	39 07       	cpc	r19, r25
  a4:	10 f0       	brcs	.+4      	; 0xaa <PinChangeInterrupt+0x46>
  {
    inState = IN_SEQU_DELAY;
	curInCh = 0;
  a6:	10 92 96 00 	sts	0x0096, r1

  //curInCh = 4; // trottle


  pinStatus = *inPin[inSequ[curInCh]];
  pinStatus >>= inBit[inSequ[curInCh]];
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	02 c0       	rjmp	.+4      	; 0xb2 <PinChangeInterrupt+0x4e>
  ae:	95 95       	asr	r25
  b0:	87 95       	ror	r24
  b2:	aa 95       	dec	r26
  b4:	e2 f7       	brpl	.-8      	; 0xae <PinChangeInterrupt+0x4a>
  //else
  //  inData[curInCh] = timeDiff;



  if(pinStatus) // pin hi
  b6:	80 ff       	sbrs	r24, 0
  b8:	04 c0       	rjmp	.+8      	; 0xc2 <PinChangeInterrupt+0x5e>
  {
    // set status
    inState = IN_PIN_HI;
  ba:	82 e0       	ldi	r24, 0x02	; 2
  bc:	80 93 99 00 	sts	0x0099, r24
  c0:	10 c0       	rjmp	.+32     	; 0xe2 <PinChangeInterrupt+0x7e>
  }
  else // pin low 
  { 

    // save time
    inData[curInCh] = timeDiff;
  c2:	80 91 96 00 	lds	r24, 0x0096
  c6:	e8 2f       	mov	r30, r24
  c8:	f0 e0       	ldi	r31, 0x00	; 0
  ca:	ee 0f       	add	r30, r30
  cc:	ff 1f       	adc	r31, r31
  ce:	ec 59       	subi	r30, 0x9C	; 156
  d0:	ff 4f       	sbci	r31, 0xFF	; 255
  d2:	31 83       	std	Z+1, r19	; 0x01
  d4:	20 83       	st	Z, r18
	inState = IN_CH_DELAY;
  d6:	91 e0       	ldi	r25, 0x01	; 1
  d8:	90 93 99 00 	sts	0x0099, r25

    // go to next ch
	curInCh++;
  dc:	8f 5f       	subi	r24, 0xFF	; 255
  de:	80 93 96 00 	sts	0x0096, r24
  }

//  if(curInCh >= MAX_IN_CH)
  if(curInCh >= 6)
  e2:	80 91 96 00 	lds	r24, 0x0096
  e6:	86 30       	cpi	r24, 0x06	; 6
  e8:	20 f0       	brcs	.+8      	; 0xf2 <PinChangeInterrupt+0x8e>
  {
    curInCh = 0;
  ea:	10 92 96 00 	sts	0x0096, r1
    inState = IN_SEQU_DELAY;
  ee:	10 92 99 00 	sts	0x0099, r1


  //inData[0]++;  

  // save time
  lastTime = time;
  f2:	50 93 b9 00 	sts	0x00B9, r21
  f6:	40 93 b8 00 	sts	0x00B8, r20
}
  fa:	08 95       	ret

000000fc <__vector_2>:


// pin change interrupt
ISR (PCINT0_vect)
{
  fc:	1f 92       	push	r1
  fe:	0f 92       	push	r0
 100:	0f b6       	in	r0, 0x3f	; 63
 102:	0f 92       	push	r0
 104:	11 24       	eor	r1, r1
 106:	8f 93       	push	r24
 108:	9f 93       	push	r25
 10a:	ef 93       	push	r30
 10c:	ff 93       	push	r31
  //PinChangeInterrupt();

  // save time
  timeBuffer[writeBufferPos] = TCNT1;
 10e:	80 91 97 00 	lds	r24, 0x0097
 112:	9f b5       	in	r25, 0x2f	; 47
 114:	e8 2f       	mov	r30, r24
 116:	f0 e0       	ldi	r31, 0x00	; 0
 118:	ee 0f       	add	r30, r30
 11a:	ff 1f       	adc	r31, r31
 11c:	e0 56       	subi	r30, 0x60	; 96
 11e:	ff 4f       	sbci	r31, 0xFF	; 255
 120:	90 83       	st	Z, r25
 122:	11 82       	std	Z+1, r1	; 0x01
  // save pin state
//  pinBuffer[writeBufferPos][0] = PINC; 
//  pinBuffer[writeBufferPos][1] = PIND;
  
  // update writeBuffer pos
  writeBufferPos++;
 124:	8f 5f       	subi	r24, 0xFF	; 255
 126:	80 93 97 00 	sts	0x0097, r24

  // set new buffer pos
  if(writeBufferPos >= BUFFER_IN_SIZE)
 12a:	84 30       	cpi	r24, 0x04	; 4
 12c:	10 f0       	brcs	.+4      	; 0x132 <__vector_2+0x36>
    writeBufferPos = 0;
 12e:	10 92 97 00 	sts	0x0097, r1

	
}
 132:	ff 91       	pop	r31
 134:	ef 91       	pop	r30
 136:	9f 91       	pop	r25
 138:	8f 91       	pop	r24
 13a:	0f 90       	pop	r0
 13c:	0f be       	out	0x3f, r0	; 63
 13e:	0f 90       	pop	r0
 140:	1f 90       	pop	r1
 142:	18 95       	reti

00000144 <main>:

void InitPort(void)
{

  // set port pins 0 and 1 as output
  DDRB = (1 << PB0)|(1 << PB1);
 144:	83 e0       	ldi	r24, 0x03	; 3
 146:	87 bb       	out	0x17, r24	; 23


  // enable pull up resistors
  PORTB = (1 << PB4)|(1 << PB5);
 148:	80 e3       	ldi	r24, 0x30	; 48
 14a:	88 bb       	out	0x18, r24	; 24
  uint16_t i;
   
  InitPort();
  //LoadSettings();

  InitTimer();
 14c:	06 d0       	rcall	.+12     	; 0x15a <InitTimer>

//  InitPinChange();

  sei();
 14e:	78 94       	sei
 150:	ff cf       	rjmp	.-2      	; 0x150 <main+0xc>

00000152 <test>:

	Test1_7(f1_7_variableA1,f1_7_variableA2);
	Test7_9(f7_9_variableB1,f1_7_variableA1);
	Test7_9_X(f7_9_variableB1,f7_9_variableB2);
	//Test11_21(f11_21_variableC1,f7_9_variableB2);
}
 152:	08 95       	ret

00000154 <Test1_7>:
		printf("Subtraction result is %d.%2.2d\n",
			temp.part.integer,
			(temp.part.fraction*100+64)/128);
	}
	*/
}
 154:	08 95       	ret

00000156 <Test7_9>:
		printf("Subtraction result is %d.%1.1d\n",
			temp.part.integer,
			(temp.part.fraction*10+256)/512);
	}
	*/
}
 156:	08 95       	ret

00000158 <Test7_9_X>:
	/*
	printf("Divide result is %d.%1.1d\n",
		temp.part.integer,
		(temp.part.fraction*10+256)/512);
		*/
}
 158:	08 95       	ret

0000015a <InitTimer>:

void Timer0_init()
{
  // set timer0 to mode 3
  // enable set bits on output compare
  TCCR0A = (1 << COM0A1)|(1 << COM0A0)|(1 << COM0B1)|(1 << COM0B0)|(1 << WGM01)|(1 << WGM00);
 15a:	83 ef       	ldi	r24, 0xF3	; 243
 15c:	8a bd       	out	0x2a, r24	; 42


	// init counter
	TCNT0 = 0x00;
 15e:	12 be       	out	0x32, r1	; 50

    // init output compare
	OCR0A = 0x40; // 1.5 ms
 160:	80 e4       	ldi	r24, 0x40	; 64
 162:	89 bd       	out	0x29, r24	; 41
    OCR0B = 0x40; // 1.5 ms
 164:	88 bd       	out	0x28, r24	; 40

    //OCR0B = 0xC0; // 1 ms

    // enable interrupts
 	TIMSK |= (1 << TOIE0);
 166:	89 b7       	in	r24, 0x39	; 57
 168:	82 60       	ori	r24, 0x02	; 2
 16a:	89 bf       	out	0x39, r24	; 57

     // start Timer0 
    TCCR0B = (1 << CS01)|(1 << CS00); // prescaler = 64
 16c:	83 e0       	ldi	r24, 0x03	; 3
 16e:	83 bf       	out	0x33, r24	; 51
void InitTimer(void)
{
  	Timer0_init();
	//Timer1_init();

}
 170:	08 95       	ret

00000172 <__vector_5>:



// Timer0 Overflow
ISR(TIMER0_OVF_vect)
{
 172:	1f 92       	push	r1
 174:	0f 92       	push	r0
 176:	0f b6       	in	r0, 0x3f	; 63
 178:	0f 92       	push	r0
 17a:	11 24       	eor	r1, r1
 17c:	8f 93       	push	r24
	// reinit counter
	//TCNT0 = 0;

  timer0Cycle++;
 17e:	80 91 9a 00 	lds	r24, 0x009A
 182:	8f 5f       	subi	r24, 0xFF	; 255
 184:	80 93 9a 00 	sts	0x009A, r24

  if(timer0Cycle == 1)
 188:	81 30       	cpi	r24, 0x01	; 1
 18a:	21 f4       	brne	.+8      	; 0x194 <__vector_5+0x22>
  {
    // disable timer0 compare A and B
	TCCR0A &= ~((1 << COM0A1)|(1 << COM0A0)|(1 << COM0B1)|(1 << COM0B0));
 18c:	8a b5       	in	r24, 0x2a	; 42
 18e:	8f 70       	andi	r24, 0x0F	; 15
 190:	8a bd       	out	0x2a, r24	; 42
 192:	07 c0       	rjmp	.+14     	; 0x1a2 <__vector_5+0x30>


  }

  if(timer0Cycle >= TIMER_0_MAX_CYCLE)
 194:	8a 30       	cpi	r24, 0x0A	; 10
 196:	28 f0       	brcs	.+10     	; 0x1a2 <__vector_5+0x30>
  {
    // enable timer0 compare A and B
    TCCR0A |= (1 << COM0A1)|(1 << COM0A0)|(1 << COM0B1)|(1 << COM0B0);
 198:	8a b5       	in	r24, 0x2a	; 42
 19a:	80 6f       	ori	r24, 0xF0	; 240
 19c:	8a bd       	out	0x2a, r24	; 42


    // reset counter 
    timer0Cycle = 0;
 19e:	10 92 9a 00 	sts	0x009A, r1
  }

}
 1a2:	8f 91       	pop	r24
 1a4:	0f 90       	pop	r0
 1a6:	0f be       	out	0x3f, r0	; 63
 1a8:	0f 90       	pop	r0
 1aa:	1f 90       	pop	r1
 1ac:	18 95       	reti

000001ae <__vector_10>:

// Timer0 Compare A
ISR(TIMER0_COMPA_vect)
{
 1ae:	1f 92       	push	r1
 1b0:	0f 92       	push	r0
 1b2:	0f b6       	in	r0, 0x3f	; 63
 1b4:	0f 92       	push	r0
 1b6:	11 24       	eor	r1, r1
}
 1b8:	0f 90       	pop	r0
 1ba:	0f be       	out	0x3f, r0	; 63
 1bc:	0f 90       	pop	r0
 1be:	1f 90       	pop	r1
 1c0:	18 95       	reti

000001c2 <__vector_11>:

// Timer0 Compare B
ISR(TIMER0_COMPB_vect)
{
 1c2:	1f 92       	push	r1
 1c4:	0f 92       	push	r0
 1c6:	0f b6       	in	r0, 0x3f	; 63
 1c8:	0f 92       	push	r0
 1ca:	11 24       	eor	r1, r1
}
 1cc:	0f 90       	pop	r0
 1ce:	0f be       	out	0x3f, r0	; 63
 1d0:	0f 90       	pop	r0
 1d2:	1f 90       	pop	r1
 1d4:	18 95       	reti

000001d6 <Timer0_init>:

void Timer0_init()
{
  // set timer0 to mode 3
  // enable set bits on output compare
  TCCR0A = (1 << COM0A1)|(1 << COM0A0)|(1 << COM0B1)|(1 << COM0B0)|(1 << WGM01)|(1 << WGM00);
 1d6:	83 ef       	ldi	r24, 0xF3	; 243
 1d8:	8a bd       	out	0x2a, r24	; 42


	// init counter
	TCNT0 = 0x00;
 1da:	12 be       	out	0x32, r1	; 50

    // init output compare
	OCR0A = 0x40; // 1.5 ms
 1dc:	80 e4       	ldi	r24, 0x40	; 64
 1de:	89 bd       	out	0x29, r24	; 41
    OCR0B = 0x40; // 1.5 ms
 1e0:	88 bd       	out	0x28, r24	; 40

    //OCR0B = 0xC0; // 1 ms

    // enable interrupts
 	TIMSK |= (1 << TOIE0);
 1e2:	89 b7       	in	r24, 0x39	; 57
 1e4:	82 60       	ori	r24, 0x02	; 2
 1e6:	89 bf       	out	0x39, r24	; 57

     // start Timer0 
    TCCR0B = (1 << CS01)|(1 << CS00); // prescaler = 64
 1e8:	83 e0       	ldi	r24, 0x03	; 3
 1ea:	83 bf       	out	0x33, r24	; 51

}
 1ec:	08 95       	ret

000001ee <__vector_4>:



// Timer1 Overflow
ISR(TIMER1_OVF_vect)
{
 1ee:	1f 92       	push	r1
 1f0:	0f 92       	push	r0
 1f2:	0f b6       	in	r0, 0x3f	; 63
 1f4:	0f 92       	push	r0
 1f6:	11 24       	eor	r1, r1
	// toggle bit
//    TEST_PORT ^= (1<<TEST_BIT);
//	TIFR1   |= (1<<TOV1);


}
 1f8:	0f 90       	pop	r0
 1fa:	0f be       	out	0x3f, r0	; 63
 1fc:	0f 90       	pop	r0
 1fe:	1f 90       	pop	r1
 200:	18 95       	reti

00000202 <__vector_3>:



// Timer1 Compare A
ISR(TIMER1_COMPA_vect)
{
 202:	1f 92       	push	r1
 204:	0f 92       	push	r0
 206:	0f b6       	in	r0, 0x3f	; 63
 208:	0f 92       	push	r0
 20a:	11 24       	eor	r1, r1
 20c:	2f 93       	push	r18
 20e:	3f 93       	push	r19
 210:	8f 93       	push	r24
 212:	9f 93       	push	r25
 214:	af 93       	push	r26
 216:	bf 93       	push	r27
 218:	ef 93       	push	r30
 21a:	ff 93       	push	r31
  uint16_t nextTimerVal;
  static uint16_t lastTimerVal;

  volatile uint8_t *thisOutPort = outPort[curCh];
 21c:	a0 91 94 00 	lds	r26, 0x0094
 220:	b0 e0       	ldi	r27, 0x00	; 0
 222:	fd 01       	movw	r30, r26
 224:	ee 0f       	add	r30, r30
 226:	ff 1f       	adc	r31, r31
 228:	e6 53       	subi	r30, 0x36	; 54
 22a:	ff 4f       	sbci	r31, 0xFF	; 255
 22c:	01 90       	ld	r0, Z+
 22e:	f0 81       	ld	r31, Z
 230:	e0 2d       	mov	r30, r0
  uint8_t           thisOutBit  = outBit[curCh];
 232:	ae 53       	subi	r26, 0x3E	; 62
 234:	bf 4f       	sbci	r27, 0xFF	; 255
 236:	ac 91       	ld	r26, X

  // toggle bit
  //TEST_PORT ^= (1<<TEST_BIT);

  
  switch(outState)
 238:	80 91 95 00 	lds	r24, 0x0095
 23c:	82 30       	cpi	r24, 0x02	; 2
 23e:	60 f1       	brcs	.+88     	; 0x298 <__vector_3+0x96>
 240:	82 30       	cpi	r24, 0x02	; 2
 242:	09 f0       	breq	.+2      	; 0x246 <__vector_3+0x44>
 244:	46 c0       	rjmp	.+140    	; 0x2d2 <__vector_3+0xd0>
  {
  case PIN_HI:
    // set pin low
    *thisOutPort &= ~(1<<thisOutBit);
 246:	80 81       	ld	r24, Z
 248:	21 e0       	ldi	r18, 0x01	; 1
 24a:	30 e0       	ldi	r19, 0x00	; 0
 24c:	02 c0       	rjmp	.+4      	; 0x252 <__vector_3+0x50>
 24e:	22 0f       	add	r18, r18
 250:	33 1f       	adc	r19, r19
 252:	aa 95       	dec	r26
 254:	e2 f7       	brpl	.-8      	; 0x24e <__vector_3+0x4c>
 256:	20 95       	com	r18
 258:	28 23       	and	r18, r24
 25a:	20 83       	st	Z, r18
    
	curCh++;
 25c:	80 91 94 00 	lds	r24, 0x0094
 260:	8f 5f       	subi	r24, 0xFF	; 255
 262:	80 93 94 00 	sts	0x0094, r24
 266:	20 91 9b 00 	lds	r18, 0x009B
 26a:	30 91 9c 00 	lds	r19, 0x009C
	//if(curCh>=MAX_OUT_CH)
	if(curCh>=7)
 26e:	87 30       	cpi	r24, 0x07	; 7
 270:	48 f0       	brcs	.+18     	; 0x284 <__vector_3+0x82>
	{
	  curCh = 0;
 272:	10 92 94 00 	sts	0x0094, r1
	  outState = SEQU_DELAY;
 276:	10 92 95 00 	sts	0x0095, r1
	  nextTimerVal = lastTimerVal + sequDelay;
 27a:	e0 91 62 00 	lds	r30, 0x0062
 27e:	f0 91 63 00 	lds	r31, 0x0063
 282:	07 c0       	rjmp	.+14     	; 0x292 <__vector_3+0x90>
    }
	else	
	{
	  outState = CH_DELAY;
 284:	81 e0       	ldi	r24, 0x01	; 1
 286:	80 93 95 00 	sts	0x0095, r24
	  // set next comepare macht to channel delay
      nextTimerVal = lastTimerVal + interChDelay;
 28a:	e0 91 60 00 	lds	r30, 0x0060
 28e:	f0 91 61 00 	lds	r31, 0x0061
 292:	e2 0f       	add	r30, r18
 294:	f3 1f       	adc	r31, r19
 296:	1d c0       	rjmp	.+58     	; 0x2d2 <__vector_3+0xd0>

	break;
  case CH_DELAY:
  case SEQU_DELAY:
    // set pin hi
    *thisOutPort |= (1<<thisOutBit);
 298:	20 81       	ld	r18, Z
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	90 e0       	ldi	r25, 0x00	; 0
 29e:	02 c0       	rjmp	.+4      	; 0x2a4 <__vector_3+0xa2>
 2a0:	88 0f       	add	r24, r24
 2a2:	99 1f       	adc	r25, r25
 2a4:	aa 95       	dec	r26
 2a6:	e2 f7       	brpl	.-8      	; 0x2a0 <__vector_3+0x9e>
 2a8:	28 2b       	or	r18, r24
 2aa:	20 83       	st	Z, r18
	// set timer to 0
	//TCNT1H = 0;
	//TCNT1L = 0;


    nextTimerVal = lastTimerVal + (uint16_t) outData[curCh];
 2ac:	e0 91 94 00 	lds	r30, 0x0094
 2b0:	f0 e0       	ldi	r31, 0x00	; 0
 2b2:	ee 0f       	add	r30, r30
 2b4:	ff 1f       	adc	r31, r31
 2b6:	ec 58       	subi	r30, 0x8C	; 140
 2b8:	ff 4f       	sbci	r31, 0xFF	; 255
 2ba:	01 90       	ld	r0, Z+
 2bc:	f0 81       	ld	r31, Z
 2be:	e0 2d       	mov	r30, r0
 2c0:	80 91 9b 00 	lds	r24, 0x009B
 2c4:	90 91 9c 00 	lds	r25, 0x009C
 2c8:	e8 0f       	add	r30, r24
 2ca:	f9 1f       	adc	r31, r25


	outState = PIN_HI;
 2cc:	82 e0       	ldi	r24, 0x02	; 2
 2ce:	80 93 95 00 	sts	0x0095, r24
   
  }
  

  // save last timer value
  lastTimerVal = nextTimerVal;
 2d2:	f0 93 9c 00 	sts	0x009C, r31
 2d6:	e0 93 9b 00 	sts	0x009B, r30

//  OCR1AH = 0xFF & (nextTimerVal >> 8);
//  OCR1AL = 0xFF & nextTimerVal; 

  OCR1A = nextTimerVal;
 2da:	ee bd       	out	0x2e, r30	; 46



}
 2dc:	ff 91       	pop	r31
 2de:	ef 91       	pop	r30
 2e0:	bf 91       	pop	r27
 2e2:	af 91       	pop	r26
 2e4:	9f 91       	pop	r25
 2e6:	8f 91       	pop	r24
 2e8:	3f 91       	pop	r19
 2ea:	2f 91       	pop	r18
 2ec:	0f 90       	pop	r0
 2ee:	0f be       	out	0x3f, r0	; 63
 2f0:	0f 90       	pop	r0
 2f2:	1f 90       	pop	r1
 2f4:	18 95       	reti

000002f6 <__vector_9>:



// Timer1 Compare B
ISR(TIMER1_COMPB_vect)
{
 2f6:	1f 92       	push	r1
 2f8:	0f 92       	push	r0
 2fa:	0f b6       	in	r0, 0x3f	; 63
 2fc:	0f 92       	push	r0
 2fe:	11 24       	eor	r1, r1
 300:	5f 93       	push	r21
 302:	6f 93       	push	r22
 304:	7f 93       	push	r23
 306:	8f 93       	push	r24
 308:	9f 93       	push	r25
 30a:	ef 93       	push	r30
 30c:	ff 93       	push	r31


  volatile uint8_t *gyroOutPort = outPort[gyroCh];
 30e:	e0 91 d8 00 	lds	r30, 0x00D8
 312:	f0 91 d9 00 	lds	r31, 0x00D9


  // set gyro pin low
  *gyroOutPort *= ~(1 << outBit[gyroCh]);
 316:	60 81       	ld	r22, Z
 318:	81 e0       	ldi	r24, 0x01	; 1
 31a:	90 e0       	ldi	r25, 0x00	; 0
 31c:	00 90 c9 00 	lds	r0, 0x00C9
 320:	02 c0       	rjmp	.+4      	; 0x326 <__vector_9+0x30>
 322:	88 0f       	add	r24, r24
 324:	99 1f       	adc	r25, r25
 326:	0a 94       	dec	r0
 328:	e2 f7       	brpl	.-8      	; 0x322 <__vector_9+0x2c>
 32a:	80 95       	com	r24
 32c:	90 95       	com	r25
 32e:	70 e0       	ldi	r23, 0x00	; 0
 330:	0e d0       	rcall	.+28     	; 0x34e <__mulhi3>
 332:	80 83       	st	Z, r24

}
 334:	ff 91       	pop	r31
 336:	ef 91       	pop	r30
 338:	9f 91       	pop	r25
 33a:	8f 91       	pop	r24
 33c:	7f 91       	pop	r23
 33e:	6f 91       	pop	r22
 340:	5f 91       	pop	r21
 342:	0f 90       	pop	r0
 344:	0f be       	out	0x3f, r0	; 63
 346:	0f 90       	pop	r0
 348:	1f 90       	pop	r1
 34a:	18 95       	reti

0000034c <Timer1_init>:
    // start timer
//	TCCR1B = (1<<CS11) ; // prescaler = 8



}
 34c:	08 95       	ret

0000034e <__mulhi3>:
 34e:	55 27       	eor	r21, r21
 350:	00 24       	eor	r0, r0

00000352 <__mulhi3_loop>:
 352:	80 ff       	sbrs	r24, 0
 354:	02 c0       	rjmp	.+4      	; 0x35a <__mulhi3_skip1>
 356:	06 0e       	add	r0, r22
 358:	57 1f       	adc	r21, r23

0000035a <__mulhi3_skip1>:
 35a:	66 0f       	add	r22, r22
 35c:	77 1f       	adc	r23, r23
 35e:	61 15       	cp	r22, r1
 360:	71 05       	cpc	r23, r1
 362:	21 f0       	breq	.+8      	; 0x36c <__mulhi3_exit>
 364:	96 95       	lsr	r25
 366:	87 95       	ror	r24
 368:	00 97       	sbiw	r24, 0x00	; 0
 36a:	99 f7       	brne	.-26     	; 0x352 <__mulhi3_loop>

0000036c <__mulhi3_exit>:
 36c:	95 2f       	mov	r25, r21
 36e:	80 2d       	mov	r24, r0
 370:	08 95       	ret

00000372 <_exit>:
 372:	f8 94       	cli

00000374 <__stop_program>:
 374:	ff cf       	rjmp	.-2      	; 0x374 <__stop_program>
